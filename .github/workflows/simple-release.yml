name: Simple Release

on:
  pull_request:
    types: [closed]
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  packages: write

jobs:
  create-release:
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch' && github.repository == 'stratus-test/stratus-gh-actions' # Only run on the base repository
    runs-on: ubuntu-latest
    outputs:
      docker_dirs: ${{ steps.find-docker.outputs.dirs }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create Release
        id: release
        uses: ./release
        with:
          draft: false
          prerelease: false

      - name: Update all action.yml and pyproject.toml files with new version
        run: |
          VERSION=${{ steps.release.outputs.new_version }}
          VERSION_NO_V=${VERSION#v}
          # Update all action.yml image tags
          find . -type f -name action.yml | while read f; do
            sed -i "s|image: \"docker://ghcr.io/.*/stratus-gh-actions/.\+:.*\"|image: \"docker://ghcr.io/${{ github.repository }}/$(basename $(dirname $f)):${VERSION}\"|" "$f"
          done
          # Update all pyproject.toml version fields
          find . -type f -name pyproject.toml | while read f; do
            sed -i "s/^version = \".*\"/version = \"${VERSION_NO_V}\"/" "$f"
          done
          if git diff --exit-code > /dev/null; then
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub App JWT and Installation Access Token
        id: jwt
        if: steps.release.outputs.changed == 'true'
        env:
          STRATUS_GA_BOT_PEM: ${{ secrets.STRATUS_GA_BOT_PEM }}
          STRATUS_GA_BOT_ID: ${{ vars.STRATUS_GA_BOT_ID }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          sudo apt-get update && sudo apt-get install -y jq openssl
          echo "$STRATUS_GA_BOT_PEM" > private-key.pem
          now=$(date +%s)
          exp=$((now + 540))
          header='{"alg":"RS256","typ":"JWT"}'
          payload="{\"iat\":$now,\"exp\":$exp,\"iss\":\"$STRATUS_GA_BOT_ID\"}"
          base64url() { openssl base64 -e -A | tr '+/' '-_' | tr -d '='; }
          header_b64=$(echo -n "$header" | base64url)
          payload_b64=$(echo -n "$payload" | base64url)
          unsigned_token="$header_b64.$payload_b64"
          signature=$(echo -n "$unsigned_token" | openssl dgst -sha256 -sign private-key.pem | base64url)
          jwt="$unsigned_token.$signature"
          installation_id=$(curl -s -H "Authorization: Bearer $jwt" -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/$GITHUB_REPOSITORY/installation | jq -r .id)
          access_token=$(curl -s -X POST -H "Authorization: Bearer $jwt" -H "Accept: application/vnd.github+json" \
            https://api.github.com/app/installations/$installation_id/access_tokens | jq -r .token)
          echo "strauts_ga_bot_installation_token=$access_token" >> $GITHUB_OUTPUT
          rm private-key.pem

      - name: Commit and push version bump via API
        id: commit-push
        if: steps.release.outputs.changed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.jwt.outputs.strauts_ga_bot_installation_token }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const version = '${{ steps.release.outputs.new_version }}';
            // Get current branch info
            const branch = context.ref.replace('refs/heads/', '');
            // Get current commit SHA of the branch
            const branchRef = await github.rest.git.getRef({ owner, repo, ref: `heads/${branch}` });
            const currentCommitSha = branchRef.data.object.sha;
            // Get current tree
            const currentCommit = await github.rest.git.getCommit({ owner, repo, commit_sha: currentCommitSha });
            // Find all action.yml and pyproject.toml files
            function findFiles(dir, pattern) {
              let results = [];
              fs.readdirSync(dir).forEach(file => {
                const filePath = path.join(dir, file);
                if (fs.statSync(filePath).isDirectory()) {
                  results = results.concat(findFiles(filePath, pattern));
                } else if (file === pattern) {
                  results.push(filePath);
                }
              });
              return results;
            }
            const actionFiles = findFiles('.', 'action.yml');
            const pyprojectFiles = findFiles('.', 'pyproject.toml');
            // Create blobs for updated files
            let tree = [];
            for (const f of actionFiles.concat(pyprojectFiles)) {
              const content = fs.readFileSync(f, 'utf8');
              const blob = await github.rest.git.createBlob({ owner, repo, content: Buffer.from(content).toString('base64'), encoding: 'base64' });
              tree.push({ path: f.replace(/^\.\//, ''), mode: '100644', type: 'blob', sha: blob.data.sha });
            }
            // Create new tree
            const newTree = await github.rest.git.createTree({ owner, repo, base_tree: currentCommit.data.tree.sha, tree });
            // Create new commit
            const newCommit = await github.rest.git.createCommit({
              owner,
              repo,
              message: `chore: bump version to ${version} [release]`,
              tree: newTree.data.sha,
              parents: [currentCommitSha]
            });
            // Update branch reference
            await github.rest.git.updateRef({ owner, repo, ref: `heads/${branch}`, sha: newCommit.data.sha });
            console.log(`Successfully updated branch ${branch} with new commit: ${newCommit.data.sha}`);

      - name: Find containerized actions
        id: find-docker
        run: |
          find . -maxdepth 2 -mindepth 2 -name Dockerfile -exec dirname {} \; | sed 's|^./||' > docker_dirs.txt
          echo "dirs=$(jq -c -R -s 'split("\n") | map(select(length > 0))' docker_dirs.txt)" >> $GITHUB_OUTPUT

  build-and-push-images:
    needs: create-release
    runs-on: ubuntu-latest
    strategy:
      matrix:
        dir: ${{ fromJson(needs.create-release.outputs.docker_dirs) }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Log in to GHCR
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}/${{ matrix.dir }}
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=ref,event=branch
            type=sha,format=short
            latest

      - name: Build and push Docker images
        env:
          DOCKER_METADATA_OUTPUT_TAGS: ${{ steps.meta.outputs.tags }}
          DOCKER_METADATA_OUTPUT_LABELS: ${{ steps.meta.outputs.labels }}
        run: |
          ORG_REPO=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')
          IMAGE=ghcr.io/$ORG_REPO/${{ matrix.dir }}
          docker buildx build \
            --push \
            --platform linux/amd64 \
            --tag $IMAGE:sha-$(git rev-parse --short=7 ${{ github.sha }}) \
            $(echo "$DOCKER_METADATA_OUTPUT_TAGS" | xargs -n 1 echo --tag) \
            $(echo "$DOCKER_METADATA_OUTPUT_LABELS" | xargs -n 1 echo --label) \
            ./${{ matrix.dir }}
